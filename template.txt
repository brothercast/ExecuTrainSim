We're building the ExecuTrainSimulator!!! It's a React app and we're just getting started. It uses ChatGPT to come up with a dynamic training simulation that executives at various levels can solve through a series of multiple choice answers that lead to consequences that the AI will use to update and embellish the scenario. The user will then be graded and have the option to compare their results to others, or, try the scenario from the perpective of another role within the company. All of the content and multiple choice questions should be generated by the AI. We should probably also have a method for them to enter their industry and have that factor into the simulation.


Here's the nacent React app we've built so far. The ExecutiveTrainingSimulator is saved in the app.js file of a react folder located in C:\Users\Anthonio\Data Science\ExecuTrainSim\executrainsim>
The ExecutiveTrainingServer (server.js) is saved in C:\Users\Anthonio\Data Science\ExecuTrainSim\executrainserver>


ðŸŸ© app.js
import React, { useState, useEffect } from 'react';    
import axios from 'axios';    
import { Card, CardContent, CardHeader, CardTitle } from './components/ui/Card';    
import Button from './components/ui/Button';    
import Select from './components/ui/Select';    
import Progress from './components/ui/Progress';    
import { Info, Star, ChevronLeft, ChevronRight } from 'lucide-react';    
import './styles/AppStyles.css';    
    
const ExecutiveTrainingSimulator = () => {    
  const [role, setRole] = useState('');    
  const [customRole, setCustomRole] = useState('');    
  const [experienceLevel, setExperienceLevel] = useState('');    
  const [difficulty, setDifficulty] = useState('');    
  const [scenario, setScenario] = useState(null);    
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);    
  const [answers, setAnswers] = useState([]);    
  const [progress, setProgress] = useState(0);    
  const [totalScore, setTotalScore] = useState(() => parseInt(localStorage.getItem('totalScore'), 10) || 0);    
  const [simulationComplete, setSimulationComplete] = useState(false);    
  const [debriefing, setDebriefing] = useState(null);    
  const [imagePath, setImagePath] = useState(null);    
  const [customAnswers, setCustomAnswers] = useState({});    
  const [useCustomScenario, setUseCustomScenario] = useState(false);    
  const [customScenarioText, setCustomScenarioText] = useState('');    
  const [errorMessage, setErrorMessage] = useState('');    
    
  const roles = [    
    { value: 'ceo', title: 'CEO - Chief Executive Officer' },    
    { value: 'cfo', title: 'CFO - Chief Financial Officer' },    
    { value: 'cmo', title: 'CMO - Chief Marketing Officer' },    
    { value: 'cto', title: 'CTO - Chief Technology Officer' },    
    { value: 'coo', title: 'COO - Chief Operations Officer' },    
    { value: 'chro', title: 'CHRO - Chief Human Resources Officer' },    
    { value: 'custom', title: 'Custom Role' }    
  ];    
    
  const experienceLevels = [    
    { value: 'junior', title: 'Junior (0-2 years)' },    
    { value: 'mid', title: 'Mid-level (3-5 years)' },    
    { value: 'senior', title: 'Senior (6-10 years)' },    
    { value: 'executive', title: 'Executive (10+ years)' }    
  ];    
    
  const difficultyLevels = [    
    { value: 'easy', title: 'Easy' },    
    { value: 'medium', title: 'Medium' },    
    { value: 'hard', title: 'Hard' },    
    { value: 'expert', title: 'Expert' }    
  ];    
    
  useEffect(() => {    
    localStorage.setItem('totalScore', totalScore);    
  }, [totalScore]);    
    
  const fetchOpenAIResponse = async (input, endpointPath) => {    
    try {    
      const response = await axios.post(`http://localhost:5000${endpointPath}`, input, { headers: { 'Content-Type': 'application/json' } });    
      return response.data;    
    } catch (error) {    
      console.error('Error fetching from OpenAI:', error);    
      throw new Error(error.response ? error.response.data : error.message);    
    }    
  };    
    
  const generateImage = async (prompt) => {    
    try {    
      const response = await axios.post('http://localhost:5001/api/dalle/image', { prompt });    
      setImagePath(response.data.imagePath);    
    } catch (error) {    
      console.error('Error generating image:', error.message);    
    }    
  };    
    
  const generateSampleScenario = async () => {  
    const missingFields = [];  
    if (!role) missingFields.push("role");  
    if (!experienceLevel) missingFields.push("experience level");  
    if (!difficulty) missingFields.push("difficulty");  
    
    if (missingFields.length > 0) {  
      setErrorMessage(`Please select a ${missingFields.join(', ')} before generating a sample scenario.`);  
      return;  
    }  
    
    try {  
      const scenarioData = await fetchOpenAIResponse(  
        {  
          role: role === 'custom' ? customRole : roles.find(r => r.value === role).title,  
          experienceLevel: experienceLevels.find(level => level.value === experienceLevel).title,  
          difficulty: difficultyLevels.find(level => level.value === difficulty).title,  
        },  
        '/api/openai/initial'  
      );  
    
      if (scenarioData && scenarioData.scenario) {  
        setCustomScenarioText(scenarioData.scenario.description);  
      } else {  
        throw new Error('Scenario data is missing or malformed');  
      }  
    } catch (error) {  
      console.error('Error generating sample scenario:', error);  
      setErrorMessage('Failed to generate sample scenario. Please try again.');  
    }  
  };  
    
  const startSimulation = async () => {    
    const selectedRole = role === 'custom' ? customRole : roles.find(r => r.value === role)?.title;    
    if (!selectedRole || !experienceLevel || !difficulty) {    
      setErrorMessage('Please select a role, experience level, and difficulty to start the simulation.');    
      return;    
    }    
    setErrorMessage(''); // Clear previous errors if any  
    
    try {    
      const scenarioData = useCustomScenario && customScenarioText    
        ? await fetchOpenAIResponse({ customScenario: customScenarioText }, '/api/openai/custom_initial')    
        : await fetchOpenAIResponse({    
            role: selectedRole,    
            experienceLevel: experienceLevels.find(level => level.value === experienceLevel).title,    
            difficulty: difficultyLevels.find(level => level.value === difficulty).title    
          }, '/api/openai/initial');    
    
      if (scenarioData && scenarioData.scenario) {    
        const titlePrefix = useCustomScenario ? "Custom Scenario: " : "";    
        scenarioData.scenario.title = `${titlePrefix}${scenarioData.scenario.title}`;    
        setScenario(scenarioData.scenario);    
        resetStateVariables();    
    
        const imagePrompt = `Illustrate the following scenario: â€œ${scenarioData.scenario.description}â€. The illustration should resemble colorful 1990s clip art with simple, clean lines and a focus on clarity. Use basic but colorful vector illustrations of the scenario, without any text. The colors should be vibrant but not overwhelming, ensuring that the images are easily understandable at a glance.`;    
        await generateImage(imagePrompt);    
      } else {    
        throw new Error('Failed to generate scenario');    
      }    
    } catch (error) {    
      console.error('Error starting simulation:', error);    
    }    
  };    
    
  const resetStateVariables = () => {    
    setCurrentQuestionIndex(0);    
    setProgress(0);    
    setTotalScore(0);    
    setAnswers([]);    
    setSimulationComplete(false);    
    setDebriefing(null);    
    setCustomAnswers({});    
  };    
    
  const handleAnswer = async (answerIndex, customAnswer = null) => {  
    if (customAnswer === null && customAnswers[currentQuestionIndex] === '') {  
      toggleCustomAnswer(currentQuestionIndex);  
      return;  
    }  
    
    const selectedOption = customAnswer || scenario.options[answerIndex].description;  
    
    try {  
      const result = await fetchOpenAIResponse({  
        role: role === 'custom' ? customRole : roles.find(r => r.value === role).title,  
        experienceLevel: experienceLevels.find(level => level.value === experienceLevel).title,  
        difficulty: difficultyLevels.find(level => level.value === difficulty).title,  
        scenario: scenario.description,  
        question: scenario.initial_question,  
        answer: selectedOption,  
        previousAnswers: answers  
      }, '/api/openai/followup');  
    
      if (result && result.next_question && result.score && result.score.feedback) {  
        const { next_question, score } = result;  
        updateStateWithAnswer(selectedOption, next_question, score);  
    
        const imagePrompt = `Illustrate the following updated scenario: "${next_question.scenario_description}".`;  
        await generateImage(imagePrompt);  
      } else {  
        console.error('Invalid response format:', result);  
      }  
    } catch (error) {  
      console.error('Error handling answer:', error);  
    }  
  };  
    
  const updateStateWithAnswer = (selectedOption, nextQuestion, score) => {    
    setTotalScore(prevScore => prevScore + score.current_score);    
    setAnswers(prevAnswers => [...prevAnswers, {    
      question: scenario.initial_question,    
      answer: { description: selectedOption },    
      feedback: score.feedback,    
      score: score.current_score,    
    }]);    
    setScenario(prevScenario => ({    
      ...prevScenario,    
      description: nextQuestion.scenario_description,    
      options: nextQuestion.options,    
      initial_question: nextQuestion.question    
    }));    
    setCurrentQuestionIndex(currentQuestionIndex + 1);    
    setProgress(prevProgress => Math.min(prevProgress + 20, 100));    
    
    if (answers.length >= 4) {    
      setSimulationComplete(true);    
      generateDebriefing();    
    }    
  };    
    
  const generateDebriefing = async () => {    
    try {    
      const debriefingData = await fetchOpenAIResponse({    
        scenario: scenario.description,    
        answers: answers    
      }, '/api/openai/debriefing');    
    
      if (debriefingData && debriefingData.debriefing) {    
        setDebriefing(debriefingData.debriefing);    
      } else {    
        throw new Error('Failed to generate debriefing');    
      }    
    } catch (error) {    
      console.error('Error generating debriefing:', error);    
    }    
  };    
    
  const resetSimulation = () => {    
    setScenario(null);    
    resetStateVariables();    
    setImagePath(null);    
    setCustomScenarioText('');    
  };    
    
  const formatTextWithLineBreaks = (text) => {    
    if (!text) return null;    
    return text.split(/\.\s+/).map((sentence, index) => (    
      <p key={index} style={{ marginBottom: '1em' }}>    
        {sentence.trim()}    
      </p>    
    ));    
  };    
    
  const goToPreviousQuestion = () => {    
    if (currentQuestionIndex > 0) {    
      setCurrentQuestionIndex(currentQuestionIndex - 1);    
    } else if (simulationComplete) {    
      setSimulationComplete(false);    
      setCurrentQuestionIndex(answers.length - 1);    
    }    
  };    
    
  const goToNextQuestion = () => {    
    if (currentQuestionIndex < answers.length) {    
      setCurrentQuestionIndex(currentQuestionIndex + 1);    
    } else if (currentQuestionIndex === answers.length && !simulationComplete) {    
      setSimulationComplete(true);    
    }    
  };    
    
  const toggleCustomAnswer = (index) => {  
    setCustomAnswers(prev => {  
      const updated = { ...prev };  
      if (updated[index]) {  
        delete updated[index];  
      } else {  
        updated[index] = '';  
      }  
      return updated;  
    });  
  };   
    
  return (  
    <div className="app-container">  
      <header className="app-header">  
        <div className="header-box">  
          <span className="header-title">Executive Training Simulation</span>  
        </div>  
      </header>  
    
      <main className="content-grid">  
        <aside className="left-column">  
          {scenario && (  
            <>  
              <div className="step-box">  
                <ChevronLeft  
                  onClick={goToPreviousQuestion}  
                  className={`nav-arrow ${currentQuestionIndex === 0 ? 'disabled' : ''}`}  
                  title="Previous Question"  
                />  
                <span>{simulationComplete && currentQuestionIndex >= answers.length ? "Summary" : `Question ${currentQuestionIndex + 1}`}</span>  
                <ChevronRight  
                  onClick={goToNextQuestion}  
                  className={`nav-arrow ${currentQuestionIndex >= answers.length && !simulationComplete ? 'disabled' : ''}`}  
                  title={simulationComplete ? "Summary" : "Next Question"}  
                />  
              </div>  
              <Card className="details-card">  
                <CardHeader>  
                  <CardTitle>Your Simulation</CardTitle>  
                </CardHeader>  
                <CardContent>  
                  <div className="progress-info">  
                    <Progress value={progress} />  
                    <span className="progress-text">{progress}% Complete</span>  
                  </div>  
                  <div className="user-settings">  
                    <p><strong>Role:</strong> {role === 'custom' ? customRole : roles.find(r => r.value === role).title}</p>  
                    <p><strong>Experience Level:</strong> {experienceLevels.find(level => level.value === experienceLevel).title}</p>  
                    <p><strong>Difficulty:</strong> {difficultyLevels.find(level => level.value === difficulty).title}</p>  
                  </div>  
                  {imagePath && <img src={imagePath} alt="Scenario Illustration" className="scenario-image" />}  
                  <Button onClick={resetSimulation} className="restart-button">Restart Simulation</Button>  
                </CardContent>  
              </Card>  
            </>  
          )}  
        </aside>  
    
        <section className="main-content">  
          {errorMessage && (  
            <div className="error-box">  
              <h4 className="error-title">  
                <Info className="icon" size={18} />  
                Error  
              </h4>  
              <p>{errorMessage}</p>  
            </div>  
          )}  
    
          {!simulationComplete ? (  
            scenario ? (  
              <Card className="scenario-card">  
                <CardHeader>  
                  <div className="scenario-title">  
                    <div className="chevron-marker"></div>  
                    <CardTitle>{scenario.title}</CardTitle>  
                  </div>  
                </CardHeader>  
                <CardContent>  
                  {currentQuestionIndex > 0 && currentQuestionIndex <= answers.length && (  
                    <div className="feedback-section">  
                      <p className="your-answer"><strong>Your Answer:</strong> {answers[currentQuestionIndex - 1]?.answer.description}</p>  
                      <div className="feedback">  
                        <h4 className="feedback-title">  
                          <Info className="icon" size={18} />  
                          Feedback  
                        </h4>  
                        <p>{answers[currentQuestionIndex - 1]?.feedback}</p>  
                      </div>  
                    </div>  
                  )}  
                  <div className="scenario-description">  
                    {formatTextWithLineBreaks(scenario.description)}  
                  </div>  
                  <h3 className="question-title">{formatTextWithLineBreaks(scenario.initial_question)}</h3>  
                  <div className="options-container">  
                    {scenario && scenario.options && scenario.options.map((option, index) => (  
                      <Button key={index} onClick={() => handleAnswer(index)} className="option-button">  
                        {option.description}  
                      </Button>  
                    ))}  
                    <div className="custom-answer-section">  
                      <div className="form-group">  
                        <label className="custom-answer-label">  
                          <input  
                            type="checkbox"  
                            checked={!!customAnswers[currentQuestionIndex]}  
                            onChange={() => toggleCustomAnswer(currentQuestionIndex)}  
                          />  
                          Submit Custom Answer  
                        </label>  
                      </div>  
                      {customAnswers[currentQuestionIndex] !== undefined && (  
                        <div className="form-group custom-answer-form">  
                          <textarea  
                            placeholder="Enter your custom answer here."  
                            value={customAnswers[currentQuestionIndex] || ''}  
                            onChange={(e) =>  
                              setCustomAnswers((prev) => ({  
                                ...prev,  
                                [currentQuestionIndex]: e.target.value,  
                              }))  
                            }  
                            rows="4"  
                            className="custom-answer-textarea"  
                          />  
                          <Button onClick={() => handleAnswer(null, customAnswers[currentQuestionIndex])}>  
                            Submit Custom Answer  
                          </Button>  
                        </div>  
                      )}  
                    </div>  
                  </div>  
                </CardContent>  
              </Card>  
            ) : (  
              <Card className="setup-card">  
                <CardHeader>  
                  <CardTitle className="header-title">Setup Your Simulation</CardTitle>  
                </CardHeader>  
                <CardContent>  
                  <div className="form-group">  
                    <label>Select your role</label>  
                    <Select onValueChange={setRole} value={role} disabled={scenario}>  
                      <option value="">Choose a role</option>  
                      {roles.map((r) => (  
                        <option key={r.value} value={r.value}>{r.title}</option>  
                      ))}  
                    </Select>  
                    {role === 'custom' && (  
                      <input  
                        type="text"  
                        className="custom-role-input"  
                        placeholder="Enter your custom role"  
                        value={customRole}  
                        onChange={(e) => setCustomRole(e.target.value)}  
                        disabled={scenario}  
                      />  
                    )}  
                  </div>  
                  <div className="form-group">  
                    <label>Select your experience level</label>  
                    <Select onValueChange={setExperienceLevel} value={experienceLevel} disabled={scenario}>  
                      <option value="">Choose experience level</option>  
                      {experienceLevels.map((level) => (  
                        <option key={level.value} value={level.value}>{level.title}</option>  
                      ))}  
                    </Select>  
                  </div>  
                  <div className="form-group">  
                    <label>Select difficulty level</label>  
                    <Select onValueChange={setDifficulty} value={difficulty} disabled={scenario}>  
                      <option value="">Choose difficulty</option>  
                      {difficultyLevels.map((level) => (  
                        <option key={level.value} value={level.value}>{level.title}</option>  
                      ))}  
                    </Select>  
                  </div>  
                  <div className="form-group">  
                    <label>  
                      <input  
                        type="checkbox"  
                        checked={useCustomScenario}  
                        onChange={() => setUseCustomScenario(!useCustomScenario)}  
                      />  
                      Use Custom Scenario  
                    </label>  
                  </div>  
                  {useCustomScenario && (  
                    <>  
                      <div className="form-group">  
                        <textarea  
                          placeholder="Enter your custom scenario here or click Generate Sample Scenario for inspiration."  
                          value={customScenarioText}  
                          onChange={(e) => setCustomScenarioText(e.target.value)}  
                          rows="6"  
                          className="custom-scenario-textarea"  
                        />  
                      </div>  
                      <Button onClick={generateSampleScenario}>Generate Sample Scenario</Button>  
                    </>  
                  )}  
                  <div className="button-group">  
                    <Button onClick={startSimulation}>Start Simulation</Button>  
                  </div>  
                </CardContent>  
              </Card>  
            )  
          ) : (  
            debriefing && (  
              <div className="debriefing-section">  
                <h4 className="debriefing-title">Simulation Debriefing</h4>  
                <p><strong>Summary:</strong> {debriefing.summary}</p>  
                <p><strong>Strengths:</strong> {debriefing.strengths ? debriefing.strengths.join(', ') : 'None'}</p>  
                <p><strong>Areas for Improvement:</strong> {debriefing.areasForImprovement ? debriefing.areasForImprovement.join(', ') : 'None'}</p>  
                <p><strong>Overall Score:</strong> {debriefing.overallScore}/100</p>  
                <p><strong>Letter Grade:</strong> {debriefing.letterGrade}</p>  
                <div className="stars-container">  
                  {[...Array(debriefing.stars || 0)].map((_, i) => (  
                    <Star key={i} className="star filled" />  
                  ))}  
                  {[...Array(5 - (debriefing.stars || 0))].map((_, i) => (  
                    <Star key={i} className="star" />  
                  ))}  
                </div>  
                <p><strong>Recommendations:</strong> {debriefing.advice}</p>  
                <div className="action-buttons">  
                  <Button onClick={() => setSimulationComplete(false)}>Try Different Choices</Button>  
                  <Button onClick={resetSimulation}>Run as Different Role</Button>  
                </div>  
              </div>  
            )  
          )}  
        </section>  
      </main>  
    </div>  
  );    
};    
    
export default ExecutiveTrainingSimulator;    

ðŸŸªserver.js
require('dotenv').config();  
const express = require('express');  
const axios = require('axios');  
const bodyParser = require('body-parser');  
const path = require('path');  
const cors = require('cors');  
  
const app = express();  
app.use(cors());  
app.use(bodyParser.json());  

app.use(express.static(path.join(__dirname, 'build')));  

app.get('*', (req, res) => {  
  res.sendFile(path.join(__dirname, 'build', 'index.html'));  
});  

const port = process.env.PORT || 3000;  
app.listen(port, () => {  
  console.log(`Server is running on port ${port}`);  
});  
  
const GPT_PORT = process.env.GPT_PORT || 5000;  
const DALLE_PORT = process.env.DALLE_PORT || 5001;  
  
const azureApiKey = process.env["AZURE_OPENAI_API_KEY"];  
const chatGptEndpoint = `${process.env["AZURE_OPENAI_ENDPOINT"]}/openai/deployments/gpt-4o-mini/chat/completions?api-version=2023-03-15-preview`;  
const dalleEndpoint = `${process.env["AZURE_OPENAI_ENDPOINT"]}/openai/deployments/Dalle3/images/generations?api-version=2024-05-01-preview`;  

// Utility function for logging requests  
const logRequest = (context, data) => {  
  console.log(`Sending request to ${context} with data:`, data);  
};  
  
// Utility function for logging errors  
const logError = (context, error) => {  
  console.error(`Error in ${context}:`, error.response ? error.response.data : error.message);  
};  
  
  
// ChatGPT Endpoints  
app.post('/api/openai/initial', async (req, res) => {  
  const { role, experienceLevel, difficulty } = req.body;  
  const prompt = `Generate an engaging business scenario for a ${role} with ${experienceLevel} experience at ${difficulty} difficulty. Create the initial question, scenario description, and several options with potential consequences for each choice. Return a JSON object with: { "scenario": { "title": "Scenario Title", "description": "Detailed scenario description", "initial_question": "The initial question for the user", "options": [ {"description": "Option 1 description"}, {"description": "Option 2 description"}, {"description": "Option 3 description"}, {"description": "Option 4 description"} ] } }`;  
  
  logRequest('Azure OpenAI', prompt);  
  
  try {  
    const response = await axios.post(  
      chatGptEndpoint,  
      {  
        model: 'gpt-4o-mini',  
        messages: [  
          { role: "system", content: "You are a helpful assistant that responds in JSON format." },  
          { role: "user", content: prompt }  
        ],  
        temperature: 0.75,  
        max_tokens: 1800  
      },  
      {  
        headers: {  
          'Content-Type': 'application/json',  
          'api-key': azureApiKey  
        }  
      }  
    );  
  
    console.log('Received response from Azure OpenAI');  
    let content = response.data.choices[0].message.content;  
    console.log('Raw content:', content);  
  
    content = content.replace(/```json|```/g, '').trim();  
  
    try {  
      const parsedContent = JSON.parse(content);  
      res.json(parsedContent);  
    } catch (parseError) {  
      console.error('Error parsing JSON:', parseError);  
      res.status(500).json({ error: 'Failed to parse JSON response', details: parseError.message });  
    }  
  } catch (error) {  
    console.error('Error in OpenAI request:', error);  
    res.status(500).json({  
      error: 'Failed to generate initial scenario',  
      details: error.response ? error.response.data : error.message  
    });  
  }  
});  

app.post('/api/openai/custom_initial', async (req, res) => {  
  const { role, experienceLevel, difficulty, customScenario } = req.body;  
  const prompt = `Given the custom scenario description: "${customScenario}", generate a title, initial question, and options with consequences suitable for a ${role} with ${experienceLevel} experience at ${difficulty} difficulty. Return a JSON object with: { "scenario": { "title": "Scenario Title", "description": "${customScenario}", "initial_question": "The initial question for the user", "options": [ {"description": "Option 1 description"}, {"description": "Option 2 description"}, {"description": "Option 3 description"}, {"description": "Option 4 description"} ] } }`;  
  
  try {  
    const response = await axios.post(  
      chatGptEndpoint,  
      {  
        model: 'gpt-4o-mini',  
        messages: [  
          { role: "system", content: "You are a helpful assistant that responds in JSON format." },  
          { role: "user", content: prompt }  
        ],  
        temperature: 0.75,  
        max_tokens: 1800  
      },  
      {  
        headers: {  
          'Content-Type': 'application/json',  
          'api-key': azureApiKey  
        }  
      }  
    );  
  
    let content = response.data.choices[0].message.content;  
    content = content.replace(/```json|```/g, '').trim();  
  
    try {  
      const parsedContent = JSON.parse(content);  
      res.json(parsedContent);  
    } catch (parseError) {  
      res.status(500).json({ error: 'Failed to parse JSON response', details: parseError.message });  
    }  
  } catch (error) {  
    res.status(500).json({  
      error: 'Failed to generate custom initial scenario',  
      details: error.response ? error.response.data : error.message  
    });  
  }  
});  

  
app.post('/api/openai/followup', async (req, res) => {  
  const { role, experienceLevel, difficulty, scenario, question, answer, previousAnswers } = req.body;  
  const prompt = `Given the scenario: "${scenario}", and the question: "${question}", you answered: "${answer}". Based on this, generate the next question and update the scenario by introducing new elements, challenges, or twists. The updated scenario should reflect changes or consequences of the previous decision, and introduce fresh dynamics that keep the user engaged. Provide feedback and a score for the chosen answer. Return a JSON object with: { "next_question": { "question": "Next question for the user", "scenario_description": "Updated scenario description introducing new dynamics", "options": [ {"description": "Option 1 description"}, {"description": "Option 2 description"}, {"description": "Option 3 description"}, {"description": "Option 4 description"} ] }, "score": { "current_score": (score), "feedback": "Detailed feedback on how the user's choice impacted the scenario" } }`;  
  
  console.log('Sending follow-up request to Azure OpenAI with prompt:', prompt);  
  
  try {  
    const response = await axios.post(  
      chatGptEndpoint,  
      {  
        model: 'gpt-4o-mini',  
        messages: [  
          { role: "system", content: "You are a helpful assistant that responds in JSON format." },  
          { role: "user", content: prompt }  
        ],  
        temperature: 0.85,  
        max_tokens: 1800  
      },  
      {  
        headers: {  
          'Content-Type': 'application/json',  
          'api-key': azureApiKey  
        }  
      }  
    );  
  
    console.log('Received response from Azure OpenAI for follow-up');  
    let content = response.data.choices[0].message.content;  
    console.log('Raw content:', content);  
  
    content = content.replace(/```json|```/g, '').trim();  
  
    try {  
      const parsedContent = JSON.parse(content);  
      res.json(parsedContent);  
    } catch (parseError) {  
      console.error('Error parsing JSON:', parseError);  
      res.status(500).json({ error: 'Failed to parse JSON response', details: parseError.message });  
    }  
  } catch (error) {  
    console.error('Error in OpenAI follow-up request:', error);  
    res.status(500).json({  
      error: 'Failed to generate follow-up scenario',  
      details: error.response ? error.response.data : error.message  
    });  
  }  
});  
  
app.post('/api/openai/debriefing', async (req, res) => {  
  const { scenario, answers } = req.body;  
  const prompt = `Provide a detailed debriefing summary for the scenario: "${scenario}" based on your answers: ${JSON.stringify(answers)}. Include strengths, areas for improvement, overall score, letter grade, and advice. Return a JSON object with: { "debriefing": { "summary": "Summary of the simulation", "strengths": ["Strength 1", "Strength 2"], "areasForImprovement": ["Improvement 1", "Improvement 2"], "overallScore": (X/150), "letterGrade": "(A-F)", "stars": (1-5), "advice": "Recommendations" } }`;  
  
  console.log('Sending debriefing request to Azure OpenAI with prompt:', prompt);  
  
  try {  
    const response = await axios.post(  
      chatGptEndpoint,  
      {  
        model: 'gpt-4o-mini',  
        messages: [  
          { role: "system", content: "You are a helpful assistant that responds in JSON format." },  
          { role: "user", content: prompt }  
        ],  
        temperature: 0.75,  
        max_tokens: 1800  
      },  
      {  
        headers: {  
          'Content-Type': 'application/json',  
          'api-key': azureApiKey  
        }  
      }  
    );  
  
    console.log('Received response from Azure OpenAI for debriefing');  
    let content = response.data.choices[0].message.content;  
    console.log('Raw content:', content);  
  
    content = content.replace(/```json|```/g, '').trim();  
  
    try {  
      const parsedContent = JSON.parse(content);  
      res.json(parsedContent);  
    } catch (parseError) {  
      console.error('Error parsing JSON:', parseError);  
      res.status(500).json({ error: 'Failed to parse JSON response', details: parseError.message });  
    }  
  } catch (error) {  
    console.error('Error in OpenAI debriefing request:', error);  
    res.status(500).json({  
      error: 'Failed to generate debriefing',  
      details: error.response ? error.response.data : error.message  
    });  
  }  
});  
  
// DALL-E Endpoint  
app.post('/api/dalle/image', async (req, res) => {  
  const { prompt } = req.body;  
  
  const requestBody = {  
    prompt,  
    size: "1024x1024",  
    n: 1,  
    quality: "standard",  
    style: "vivid"  
  };  
  
  logRequest('DALL-E', requestBody);  
  
  try {  
    const response = await axios.post(  
      dalleEndpoint,  
      requestBody,  
      {  
        headers: {  
          'Content-Type': 'application/json',  
          'api-key': azureApiKey  
        }  
      }  
    );  
  
    console.log('Received response from DALL-E');  
  
    if (response.data && response.data.data.length > 0) {  
      const imageUrl = response.data.data[0].url;  
      res.json({ imagePath: imageUrl });  
    } else {  
      res.status(500).json({ error: 'No images generated.' });  
    }  
  } catch (error) {  
    logError('DALL-E Request', error);  
    res.status(500).json({ error: 'Failed to generate image', details: error.message });  
  }  
});  

  
app.listen(GPT_PORT, () => {  
  console.log(`GPT server is running on port ${GPT_PORT}`);  
});  
  
app.listen(DALLE_PORT, () => {  
  console.log(`DALL-E server is running on port ${DALLE_PORT}`);  
});  


ðŸŸ¥ AppStyles.css:
body {  
  font-family: 'Arial', sans-serif;  
  background-color: #f4f7fa;  
  margin: 0;  
  padding: 0;  
}  
  
.app-container {  
  max-width: 1200px;  
  margin: 0 auto;  
  padding: 20px;  
}  
  
.app-header {  
  display: flex;  
  align-items: center;  
  background: linear-gradient(to right, #f0a202, #ea3f07);  
  padding: 10px;  
  position: fixed;  
  width: 100%;  
  top: 0;  
  left: 0;  
  z-index: 1000;
  box-shadow: 0 5px 4px rgba(0, 0, 0, 0.0.6);   
}  
  
.header-box {  
  display: flex;  
  align-items: center;  
  color: #fff;  
  font-weight: bold;  
  font-size: 18px;  
}  
  
.header-title {  
  text-transform: uppercase;  
  font-size: 40px;  
  font-family: 'Jura', sans-serif;  
}  
  
.content-grid {  
  display: grid;  
  grid-template-columns: 1fr 3fr;  
  gap: 20px;  
  margin-top: 80px;  
}  
  
.left-column {  
  background-color: #f8f9fa;  
  padding: 20px;  
  border-radius: 8px;  
  margin-bottom: 20px; /* Add margin at the bottom for spacing between elements */  
}  
  
.step-box {  
  background-color: #e0e0e0;  
  padding: 15px; /* Increase padding for more space inside the box */  
  border-radius: 4px;  
  margin-bottom: 20px; /* Add margin to separate from other elements */  
  font-weight: bold;  
  text-align: center;  
}  
  
.details-card {  
  margin-bottom: 20px; /* Ensure space between the card and other elements */  
}  
  


.custom-role-input {
  margin-top: 10px;
}
  
.progress-info {  
  display: flex;  
  align-items: center;  
  margin-top: 10px;  
}  
  
.progress-bar {  
  flex-grow: 1;  
  margin-right: 10px;  
}  
  
.progress-text {  
  font-size: 14px;  
  font-weight: bold;  
}  
  
.user-settings {  
  margin-top: 15px; /* Add space above the user settings */  
}  
  
.user-settings p {  
  margin: 10px 0; /* Add vertical margin between paragraphs */  
}  
   
.main-content {  
  background-color: #ffffff;  
  padding: 20px;  
  border-radius: 8px;  
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.0.6);  
}  

.custom-scenario-textarea {  
  width: 100%;  
  padding: 8px;  
  border-radius: 4px;  
  border: 1px solid #ccc;  
  margin-bottom: 10px;  
}  

  
.scenario-card {  
  border: 2px solid #ddd;  
  border-radius: 8px;  
  padding: 20px;  
}  
  
.scenario-title  {  
  display: flex;  
  align-items: center;  
  color: #0073e6;  
  font-weight: bold;  
  font-size: 20px;  
  text-transform: uppercase;  
  font-family: 'Jura', sans-serif;  
  margin-bottom: 10px;  
}  

.Card-title, .debriefing-title {  
  text-transform: uppercase;  
  font-size: 32px;
  color: #0073e6;  
  font-family: 'Jura', sans-serif;  
}  

.Card card-setup {
  border: 2px solid #ccc
}
  
.chevron-marker {  
  width: 20px;  
  height: 20px;  
  background-color: #0073e6;  
  clip-path: polygon(0 0, 100% 50%, 0 100%);  
  margin-right: 10px; 
 }  
  
.form-group {  
  margin-bottom: 20px;  
}  
  
.form-group label {  
  display: block;  
  font-weight: bold;  
  margin-bottom: 5px;  
}  
  
.custom-role-input {  
  width: 100%;  
  padding: 8px;  
  border-radius: 4px;  
  border: 1px solid #ccc;  
}  

.your-answer {
  top: -15px;  
  margin-bottom: 40px;
} 
  
.feedback-section {  
  margin-top: 10px; 
}  
  
.feedback {  
  background-color: #e0f7fa;  
  padding: 20px 20px 0px;  
  padding-top: 1px;  
  border-radius: 8px;  
  position: relative;  
  margin-top: 10px;
  border: 1px solid #0073e6;  
}  
  
.feedback-title {  
  font-weight: bold;  
  color: #0073e6;  
  display: flex;  
  align-items: center;  
  position: absolute;  
  top: -47.5px;  
  left: 20px;  
  background-color: #e0f7fa;  
  padding: 4px 10px;  
  border-radius: 5px 5px 0 0;  
  box-shadow: 0 -1px 0 #0073e6, 1px 0 0 #0073e6, -1px 0 0 #0073e6;
  border-bottom: 0px solid #e0f7fa;  
}  
  
.feedback-title .icon {  
  margin-right: 5px;  
}  


 

  
.scenario-description, .question-title {  
  margin-bottom: 15px;  
}  
  
.options-container {  
  display: flex;  
  flex-direction: column;  
}  
  
.option-button {  
  margin-bottom: 15px;  
  text-align: left;  
}  

.Button {  
  margin-bottom: 10px;  
  text-align: left;  
}  

.scenario-image {  
  width: 100%;  
  height: auto;   
  margin: 20px auto;  
  display: block;
  border: 2px solid #ccc;   
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);    
}    

.restart-button {  
  display: block;  
  margin: 20px auto; /* Center the button */  
  background-color: red; /* Change button color to red */  
  color: white; /* Text color */  
  padding: 10px 20px; /* Add padding */  
  border: none; /* Remove border */  
  border-radius: 5px; /* Rounded corners */  
  cursor: pointer; /* Pointer cursor on hover */  
  font-weight: bold; /* Bold text */  
}  
  
.restart-button:hover {  
  background-color: darkred; /* Darker shade on hover */  
}  

.custom-answer-section {  
  margin-top: 15px;  
}  
  
.custom-answer-label {  
  display: flex;  
  align-items: center;  
}  
  
.custom-answer-form {  
  margin-top: 10px;  
}  
  
.custom-answer-textarea {  
  width: 100%;  
  padding: 8px;  
  border-radius: 4px;  
  border: 1px solid #ccc;  
  margin-bottom: 10px;  
  resize: vertical;  
}  

.debriefing-section {  
  margin-top: 10px;  
  background-color: #f8f9fa;  
  padding: 20px;  
  border-radius: 8px;  
}  
  
 
.stars-container {  
  display: flex;  
  align-items: center;  
  margin-bottom: 10px;  
}  
  
.star {  
  width: 24px;  
  height: 24px;  
  margin-right: 5px;  
  color: #ccc;  
}  
  
.star.filled {  
  color: #ffd700;  
}  
  
.action-buttons {  
  margin-top: 20px;  
  display: flex;  
  gap: 10px;  
}  
  
.icon {  
  margin-right: 5px;  
}  
  
.image-container img {  
  width: 100%;  
  border-radius: 12px; /* Rounded corners for the image */  
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);  
}  

.step-box {  
  display: flex;  
  align-items: center;  
  justify-content: space-between;  
}  
  
.navigation-buttons {  
  display: flex;  
  gap: 10px;  
}  
  
.nav-arrow {  
  cursor: pointer;  
  font-size: 24px;  
  color: #333;  
}  
  
.nav-arrow.disabled {  
  color: #ccc;  
  cursor: not-allowed;  
}  
  
.nav-arrow:hover:not(.disabled) {  
  color: #007bff;  
}  


@media (max-width: 768px) {  
  .content-grid {  
    grid-template-columns: 1fr;  
  }  
}  

.error-box {  
  background-color: #fdecea; /* Light red background */  
  padding: 0px 20px 0px;  
  border-radius: 8px;  
  position: relative;  
  margin-top: 10px;  
  border: 1px solid #f5c6cb;
}  
  
.error-title {  
  font-weight: bold;  
  color: #c0392b; /* Dark red for title */  
  display: flex;  
  align-items: center;  
  position: absolute;  
  top: -47px;  
  left: 20px;  
  background-color: #fdecea; 
  padding: 4px 10px;  
  border-radius: 5px 5px 0 0;  
  box-shadow: 0 -1px 0 #f5c6cb, 1px 0 0 #f5c6cb, -1px 0 0 #f5c6cb;
  border-bottom: 0px solid #f5c6cb;
}  
  
.error-title .icon {  
  margin-right: 5px;  
  color: #c0392b;
}  